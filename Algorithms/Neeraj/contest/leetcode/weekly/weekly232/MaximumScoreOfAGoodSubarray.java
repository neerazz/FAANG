package weekly.weekly232;

/**
 * Created on:  Mar 13, 2021
 * Questions:
 */

public class MaximumScoreOfAGoodSubarray {

    public static void main(String[] args) {
        System.out.println(maximumScore(new int[]{1, 4, 3, 7, 4, 5}, 3));
        System.out.println(maximumScore_segmentTree(new int[]{1, 4, 3, 7, 4, 5}, 3));

        System.out.println(maximumScore(new int[]{1339, 6671, 9827, 4155, 5138, 3088, 86, 3742, 462, 5139, 1983, 112, 8362, 8298, 9858, 411, 1986, 633, 593, 1664, 403, 4775, 9969, 8508, 2288, 3163, 5907, 4817, 5789, 7599, 1750, 5842, 6051, 7737, 1641, 6176, 736, 487, 2078, 3195, 3074, 4649, 5352, 4262, 771, 5541, 3291, 905, 7502, 3128, 4001, 3849, 1518, 4577, 1505, 2104, 6123, 6052, 3796, 2869, 4530, 3752, 8086, 3221, 2136, 8112, 3055, 645, 941, 5053, 8895, 3363, 5241, 9581, 8109, 4728, 6376, 8655, 9778, 8774, 9827, 2489, 7656, 2204, 858, 3755, 7108, 2451, 7350, 9020, 9777, 8593, 7856, 1721, 1507, 1856, 8200, 7446, 9211, 5049, 4554, 6934, 6940, 6660, 1189, 9538, 1547, 5744, 6621, 6852, 6910, 5425, 2976, 4325, 1080, 4575, 7550, 6960, 3943, 8344, 4164, 2606, 8544, 2512, 633, 6797, 2909, 9089, 6036, 1641, 5410, 5865, 7845, 2080, 1470, 6976, 5972, 7485, 4391, 3387, 9871, 5950, 4080, 9122, 5233, 4752, 6394, 1311, 1922, 908, 7340, 1012, 1856, 2879, 7480, 8188, 1077, 2748, 8367, 1219, 5051, 1077, 2433, 9044, 7171, 6221, 1637, 4559, 3842, 7776, 4102, 352, 780, 8010, 4444, 8497, 4531, 1730, 3796, 3365, 1133, 1065, 3208, 5833, 9135, 7029, 4892, 8922, 2344, 1389, 983, 3091, 1509, 2925, 4795, 1776, 2956, 7767, 9311, 9311, 897, 6195, 2563, 9874, 3318, 4005, 4179, 4561, 5257, 6768, 7584, 4962, 4428, 841, 6683, 3657, 4742, 483, 8287, 9636, 4625, 5354, 1469, 683, 3423, 9621, 1138, 2600, 6, 933, 7545, 5753, 5541, 2589, 4754, 8248, 7392, 8827, 9750, 9457, 4129, 4527, 9825, 5993, 266, 3257, 9438, 9293, 955, 9182, 6583, 1785, 7492, 2192, 1167, 2398, 2568, 2260, 6639, 2289, 1143, 742, 8083, 5567, 57, 1640, 2486, 6070, 6854, 8619, 4147, 2188, 2969, 6969, 7710, 2407, 6617, 2631, 1977, 2984, 1051, 9044, 8088, 5646, 8940, 9643, 9298, 6193, 9799, 9083, 7639, 9123, 5261, 6692, 650, 4410, 9158, 242, 4468, 2686, 3117, 365, 2335, 2911, 4896, 8764, 8668, 7682, 948, 121, 7638, 1265, 7065, 6076, 2002, 5713, 9644, 6710, 7931, 7941, 6316, 6789, 7459, 6360, 8354, 4090, 2090, 955, 7240, 7441, 6605, 6307, 7419, 1352, 2021, 9526, 1361, 9793, 2922, 5115, 2714, 3032, 9769, 9902, 6489, 1358, 848, 6371, 2772, 9735, 352, 4905, 6349, 4556, 2722, 3231, 3610, 2142, 6818, 1123, 6053, 87, 625, 1143, 5188, 6749, 3324, 2049, 4498, 1440, 4345, 7608, 1661, 8448, 6398, 2805, 7022, 7440, 5196, 2739, 6302, 1515, 3004, 6917, 4344, 5278, 9726, 6595, 6856, 3723, 9639, 6232, 9926, 7887, 8172, 1112, 9938, 5614, 8480, 7042, 7279, 1882, 1079, 2768, 9831, 3853, 6121, 169, 6833, 8763, 7112, 8526, 6866, 3601, 7581, 2275, 1668, 2778, 3310, 9168, 1448, 9264, 1371, 644, 6003, 1134, 7397, 7203, 9164, 807, 226, 4353, 1974, 1682, 1750, 1437, 3032, 7964, 46, 1065, 8740, 9515, 9349, 1837, 1025, 5400, 6885, 9475, 3392, 615, 9241, 4005, 9006, 5468, 8618}, 232));
        System.out.println(maximumScore_segmentTree(new int[]{1339, 6671, 9827, 4155, 5138, 3088, 86, 3742, 462, 5139, 1983, 112, 8362, 8298, 9858, 411, 1986, 633, 593, 1664, 403, 4775, 9969, 8508, 2288, 3163, 5907, 4817, 5789, 7599, 1750, 5842, 6051, 7737, 1641, 6176, 736, 487, 2078, 3195, 3074, 4649, 5352, 4262, 771, 5541, 3291, 905, 7502, 3128, 4001, 3849, 1518, 4577, 1505, 2104, 6123, 6052, 3796, 2869, 4530, 3752, 8086, 3221, 2136, 8112, 3055, 645, 941, 5053, 8895, 3363, 5241, 9581, 8109, 4728, 6376, 8655, 9778, 8774, 9827, 2489, 7656, 2204, 858, 3755, 7108, 2451, 7350, 9020, 9777, 8593, 7856, 1721, 1507, 1856, 8200, 7446, 9211, 5049, 4554, 6934, 6940, 6660, 1189, 9538, 1547, 5744, 6621, 6852, 6910, 5425, 2976, 4325, 1080, 4575, 7550, 6960, 3943, 8344, 4164, 2606, 8544, 2512, 633, 6797, 2909, 9089, 6036, 1641, 5410, 5865, 7845, 2080, 1470, 6976, 5972, 7485, 4391, 3387, 9871, 5950, 4080, 9122, 5233, 4752, 6394, 1311, 1922, 908, 7340, 1012, 1856, 2879, 7480, 8188, 1077, 2748, 8367, 1219, 5051, 1077, 2433, 9044, 7171, 6221, 1637, 4559, 3842, 7776, 4102, 352, 780, 8010, 4444, 8497, 4531, 1730, 3796, 3365, 1133, 1065, 3208, 5833, 9135, 7029, 4892, 8922, 2344, 1389, 983, 3091, 1509, 2925, 4795, 1776, 2956, 7767, 9311, 9311, 897, 6195, 2563, 9874, 3318, 4005, 4179, 4561, 5257, 6768, 7584, 4962, 4428, 841, 6683, 3657, 4742, 483, 8287, 9636, 4625, 5354, 1469, 683, 3423, 9621, 1138, 2600, 6, 933, 7545, 5753, 5541, 2589, 4754, 8248, 7392, 8827, 9750, 9457, 4129, 4527, 9825, 5993, 266, 3257, 9438, 9293, 955, 9182, 6583, 1785, 7492, 2192, 1167, 2398, 2568, 2260, 6639, 2289, 1143, 742, 8083, 5567, 57, 1640, 2486, 6070, 6854, 8619, 4147, 2188, 2969, 6969, 7710, 2407, 6617, 2631, 1977, 2984, 1051, 9044, 8088, 5646, 8940, 9643, 9298, 6193, 9799, 9083, 7639, 9123, 5261, 6692, 650, 4410, 9158, 242, 4468, 2686, 3117, 365, 2335, 2911, 4896, 8764, 8668, 7682, 948, 121, 7638, 1265, 7065, 6076, 2002, 5713, 9644, 6710, 7931, 7941, 6316, 6789, 7459, 6360, 8354, 4090, 2090, 955, 7240, 7441, 6605, 6307, 7419, 1352, 2021, 9526, 1361, 9793, 2922, 5115, 2714, 3032, 9769, 9902, 6489, 1358, 848, 6371, 2772, 9735, 352, 4905, 6349, 4556, 2722, 3231, 3610, 2142, 6818, 1123, 6053, 87, 625, 1143, 5188, 6749, 3324, 2049, 4498, 1440, 4345, 7608, 1661, 8448, 6398, 2805, 7022, 7440, 5196, 2739, 6302, 1515, 3004, 6917, 4344, 5278, 9726, 6595, 6856, 3723, 9639, 6232, 9926, 7887, 8172, 1112, 9938, 5614, 8480, 7042, 7279, 1882, 1079, 2768, 9831, 3853, 6121, 169, 6833, 8763, 7112, 8526, 6866, 3601, 7581, 2275, 1668, 2778, 3310, 9168, 1448, 9264, 1371, 644, 6003, 1134, 7397, 7203, 9164, 807, 226, 4353, 1974, 1682, 1750, 1437, 3032, 7964, 46, 1065, 8740, 9515, 9349, 1837, 1025, 5400, 6885, 9475, 3392, 615, 9241, 4005, 9006, 5468, 8618}, 232));

        System.out.println(maximumScore(new int[]{6569, 9667, 3148, 7698, 1622, 2194, 793, 9041, 1670, 1872}, 5));
        System.out.println(maximumScore_segmentTree(new int[]{6569, 9667, 3148, 7698, 1622, 2194, 793, 9041, 1670, 1872}, 5));
    }

    public static int maximumScore_rev2(int[] nums, int k) {
//        Scan starting from index k, to left and right, respectively; Compute currently minimum value for each index and save it in mins;
        int[] mins = new int[nums.length];
        mins[k] = nums[k];
        for (int i = k + 1; i < nums.length; ++i) {
            mins[i] = Math.min(mins[i - 1], nums[i]);
        }
        for (int i = k - 1; i >= 0; --i) {
            mins[i] = Math.min(mins[i + 1], nums[i]);
        }
        int score = mins[k], left = 0, right = nums.length - 1;
//        Then starting from both ends as the first good subarray, move the end corresponds to smaller value of the mins, and update the score accordingly.
        while (left < right) {
            score = Math.max(score, (right - left + 1) * Math.min(mins[left], mins[right]));
            if (right == k || mins[left] < mins[right]) {
//                right has reached k, The only option you have to increase left
//                left have lowest min, so by increasing the left side, the minimum value will be increased.
                ++left;
            } else {
                --right;
            }
        }
        return score;
    }

    public static int maximumScore(int[] nums, int k) {
        int len = nums.length, left = k, right = k;
        long max = right, min = nums[k];
        while (left > 0 || right < len - 1) {
            if (left == 0) {
//                Reached the start there is no any option, then increasing right;
                right++;
            } else if (right == len - 1) {
//                Reached end there is no any option then reducing left pointer
                left--;
            } else if (nums[left] < nums[right]) {
                right++;
            } else {
                left--;
            }
            min = Math.min(min, Math.min(nums[right], nums[left]));
            max = Math.max(max, min * (right - left + 1));
        }
        return (int) max;
    }

    public static int maximumScore_segmentTree(int[] nums, int k) {
        int len = nums.length;
        int[] sTree = new int[4 * len];
        buildSTree(nums, 0, len - 1, sTree, 0);
        long max = 0;
        for (int i = k; i >= 0; i--) {
            for (int j = k; j < len; j++) {
                int min = query(i, j, sTree, 0, len - 1, 0);
                long cur = (long) min * (j - i + 1);
                if (max < cur) {
                    max = Math.max(max, cur);
                    System.out.println("Replacing Max at [" + i + ", " + j + "] =" + max);
                }
            }
        }
        return (int) max;
    }

    private static int query(int qs, int qe, int[] sTree, int s, int e, int i) {
        if (qs > e || qe < s) return Integer.MAX_VALUE;
        if (qs <= s && e <= qe) return sTree[i];
        int m = (s + e) / 2, left = 2 * i + 1, right = 2 * i + 2;
        return Math.min(query(qs, qe, sTree, s, m, left), query(qs, qe, sTree, m + 1, e, right));
    }

    private static void buildSTree(int[] nums, int s, int e, int[] sTree, int i) {
        if (e < s) return;
        if (s == e) {
            sTree[i] = nums[s];
        } else {
            int m = (s + e) / 2, left = 2 * i + 1, right = 2 * i + 2;
            buildSTree(nums, s, m, sTree, left);
            buildSTree(nums, m + 1, e, sTree, right);
            sTree[i] = Math.min(sTree[left], sTree[right]);
        }
    }
}
